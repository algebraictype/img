Concurrency can potentially make your program more efficient in areas where tasks can be performed independently and in parallel. In your codebase, one potential area for concurrency could be the loading and processing of images.  Currently, your init_graphics function is doing several things sequentially:
Initializing SDL2's video engine and image renderer.
Loading an image and getting its resolution.
Creating an SDL window and renderer.
Creating an SDL texture from the loaded image.
Handling events.
Some of these tasks might be able to run concurrently. For example, you could potenti

ally load and process multiple images at the same time on different threads, rather than waiting for each image to load and process sequentially. This could be particularly beneficial if you have a large number of images to process, or if the images are large and take a significant amount of time to load and process.  Here's a rough idea of how you might modify your init_graphics function to load and process images concurrently:


#include <future>

int image::init_graphics(const std::vector<std::string> &file_names){
    // Initialize SDL2's video engine and image renderer as before.
    // ...

    // Create an SDL window and renderer as before.
    // ...

    // Create a vector to hold futures.
    std::vector<std::future<SDL_Texture*>> futures;

    for (const auto& file_name : file_names) {
        // Launch a new task to load and process each image.
        futures.push_back(std::async(std::launch::async, [&]() {
            // Load the image and get its resolution.
            image::ImageHandler image_instance;
            image_instance.get_resolution(file_name);

            SDL_Surface* loaded_img = IMG_Load(file_name.c_str());
            if (loaded_img == NULL) {
                std::cerr << "img: Invalid filetype: " << IMG_GetError() << std::endl;
                exit(EXIT_FAILURE);
            }

            // Create an SDL texture from the loaded image.
            SDL_Texture* tex = SDL_CreateTextureFromSurface(ren, loaded_img);
            if (tex == NULL) {
                std::cout << "SDL2_INIT_TEXTURE_ERR: "<<SDL_GetError();
                exit(EXIT_FAILURE);
            }

            // Free the SDL surface.
            SDL_FreeSurface(loaded_img);

            return tex;
        }));
    }

    // Wait for all tasks to complete and collect the results.
    for (auto& future : futures) {
        SDL_Texture* tex = future.get();
        // Do something with tex...
    }

    // Continue with the rest of your function as before.
    // ...
}

Based on your codebase, here are some specific functions where concurrency might be beneficial:
image::file_to_texture: This function loads an image file and converts it into an SDL_Texture. If you have multiple images to load, you could potentially load and convert them concurrently.
image::ImageHandler::get_resolution: This function loads an image file to get its resolution. If you need to get the resolution of multiple images, you could potentially do this concurrently.
handle_events: This function handles SDL events in a loop. If there are other tasks that can be performed independently of event handling (such as image processing), these could potentially be done concurrently.
advance_file: This function loads a new image file and initializes a texture from it. If you have multiple files to advance through, you could potentially do this concurrently.
Remember, introducing concurrency can make your code more complex and harder to debug, so it's important to only
 use it where it's truly beneficial. Also, not all tasks can be performed concurrently due to dependencies between them. For example, you can't render an image before it's loaded. So, you'll need to carefully analyze your code to determine where concurrency can be effectively used.

 #include <future>
 #include <mutex>

 std::mutex ren_mutex;

 SDL_Texture* image::file_to_texture(SDL_Renderer* ren, const std::string& image_name, image::ImageHandler& image_instance){

     // Load the image and get its resolution in a separate thread.
     auto future = std::async(std::launch::async, [&]() {
         image_instance.get_resolution(image_name);
         SDL_Surface* next_image = IMG_Load(image_name.c_str());
         if(next_image == NULL){
             // Handle error...
         }
         return next_image;
     });

     // Wait for the image loading and resolution getting to complete.
     SDL_Surface* next_image = future.get();

     // Lock the mutex before accessing the shared renderer.
     std::lock_guard<std::mutex> lock(ren_mutex);
     SDL_Texture* next_texture = SDL_CreateTextureFromSurface(ren,next_image);
     if(next_texture == NULL){
         // Handle error...
     }

     // Continue with the rest of your function as before.
     // ...

     return next_texture;
 }

 while (!quit) {
     // Launch a new thread to process the image.
     std::future<void> future = std::async(std::launch::async, [&]() {
         // Process the image...
     });

     // Handle events...
     handle_events();

     // Wait for the image processing to complete.
     future.get();

     // Draw the image...
 }

 In the example provided, the main thread launches a new thread to load the image and get its resolution. While this new thread is performing these tasks, the main thread continues to execute. It could be handling user input, updating the user interface, or performing other tasks.

 However, when the main thread calls `future.get()`, it will block and wait if the new thread has not yet finished its tasks. This is necessary to ensure that the image is fully loaded and its resolution is obtained before the main thread tries to use this data.

 So, while the image is being loaded and its resolution is being gathered on the new thread, the main thread could be doing other work. But eventually, it will need to wait for the new thread to finish its tasks before it can proceed. This is the trade-off when using multithreading: you can perform tasks concurrently, but you often need to synchronize threads to ensure that data is fully prepared before it's used.

 Yes, that's correct. In the provided example, the main thread enters the `file_to_texture` function and then creates a new thread within this function to load the image and get its resolution. While the new thread is performing these tasks, the main thread continues to execute the rest of the `file_to_texture` function until it reaches the point where it needs the results from the new thread. At this point, the main thread will wait for the new thread to finish its tasks by calling `future.get()`.



 if(files.get_file_counter() < files.working_dir_size()) files.add_to_file_counter(1); //advance dir position
 if(files.get_file_counter() >= files.working_dir_size()){
     files.set_file_counter(0); //directory circularity
 }

 if(GraphicsInstance.texture != NULL){
     std::cout << "GraphicsInstance.texture != NULL" << std::endl;
     SDL_DestroyTexture(GraphicsInstance.texture); //destroy previously drawn image
     GraphicsInstance.texture = NULL;
 }

 files.identify_filetype(files.get_current_file());

 std::cout << "FILETYPE: " << static_cast<int>(files.get_file_type()) << std::endl;
 std::cout << "CURRENT_FILE: " << files.get_current_file() << std::endl;
 std::cout << "FILE_COUNTER: " << files.get_file_counter() << std::endl;

 if(files.get_file_type() == FileType::JPG || files.get_file_type() == FileType::PNG){
     std::cout << "Img -> Opening: " << files.get_current_file() << std::endl;
     auto future = std::async(std::launch::async, [&](){
         try {
             return image::file_to_texture(GraphicsInstance.renderer, files.get_current_file(), image_instance);
         } catch (const std::bad_alloc& e) {
             std::cerr << "Failed to allocate memory for file: " << files.get_current_file() << '\n';
             std::cerr << "Exception: " << e.what() << '\n';
             return static_cast<SDL_Texture*>(nullptr);  // Return nullptr on failure
         }
     });
     image_instance.get_resolution(files.get_current_file());
     init_lens(&lens, image_instance);
     GraphicsInstance.texture = future.get();  // Wait for the task to complete and get the result
     if (GraphicsInstance.texture != nullptr) {
         image::draw(GraphicsInstance, lens);
         printf("%d, %d\n", lens.w, lens.h);
     }
     event.key.repeat = 0;
     SDL_RenderClear(GraphicsInstance.renderer);
     break;
 }